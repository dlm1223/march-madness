---
title: "Choosing the Best Scoring System For Your March Madness Pool"
date: "March 11, 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

<br />I made an [app](https://bracketmath.shinyapps.io/ncaa/) to optimize March Madness brackets. You can read more about it [here](https://github.com/dlm1223/march-madness/blob/master/README.md). I've been backtesting its performance using the actual March Madness results from 2010-2017. In previous posts I looked at [optimal algorithm parameters and optimal pool size](https://www.brianlefevre.com/wp-content/uploads/2018/03/march_madness_backtest.html), and I also did [sensitivity analysis ](https://www.brianlefevre.com/wp-content/uploads/2018/03/march_madness_sensitivity.html) to test those findings. In this post, I'll analyze different scoring systems and different pool payout structures and give suggestions on how you should design your pool. <br /><br />


## Testing Scoring Systems

I test 7 different scoring systems, outlined in the following table: <br />
![](readme.png) <br /><br />  Every time you run the algorithm for a given year it spits out a probability of acheiving the inputted percentile and so I can get things like expected total number of wins and expected total profit over the 8 years. I already established in previous posts that diversifying is ideal and so I'm just going to be looking at single-entry strategies in this post. <br /><br />



```{r , echo=F, eval=T , include=F }
library(plyr);library(dplyr);library(ggplot2);library(ggrepel)

files<-list.files(pattern="backtest results")
files<-files[!grepl("v2", files)]

getFiles<-function(file){
  load(file)
  backtest$Type<-gsub("backtest results |[.]Rda","", file)
  backtest$Type
  backtest
}

backtest<-ldply(lapply(files, getFiles), data.frame)
backtest$Type[backtest$Type=="UpsetsDoubled"]<-"Exponential UpsetsDoubled"
backtest$Type[backtest$Type=="backtest results"]<-"Exponential"
backtest$Type<-gsub("Exponential", "Exp", backtest$Type)
backtest$Type<-gsub("Arithmetic", "Arith", backtest$Type)
backtest$numWinning<-rowSums(apply(backtest[, grepl("result", colnames(backtest))],2, function(x) x>=backtest$percentile  ), na.rm=T)
backtest$numSecond<-rowSums(apply(backtest[, grepl("result", colnames(backtest))],2, function(x) x<backtest$percentile & x>=backtest$percentile-(1-backtest$percentile) ), na.rm=T)
backtest$Prize<-(1/(1-backtest$percentile))*backtest$numWinning
backtest$Prize_same<-(1/(1-backtest$percentile))*(backtest$numWinning>=1)
```

```{r , echo=F, eval=T , include=T ,fig.height = 3, fig.width =9, fig.align = "center"}

backtest<-backtest[backtest$numBrackets==1,]

means<-ddply(backtest, .(Type, percentile, numBrackets),summarize,  expectedNumLosses=sum(1-probWin),
             expectedNumWins=sum(probWin),expectedProfit=sum(probWin*1/(1-percentile)))
means$numBrackets<-as.factor(means$numBrackets)
means$percentile<-as.factor(means$percentile)

a<-ggplot(data=means, aes(fill=percentile, y=expectedProfit, x=Type)) +  
  geom_bar(position="dodge", stat="identity"    ,
           colour="black", # Use black outlines,
           size=.3) +      # Thinner lines
  ggtitle("Expected Total Profit by Scoring, Winner Take All")
plot(a)

a<-ggplot(data=means, aes(fill=percentile, y=expectedNumWins, x=Type)) +  
  geom_bar(position="dodge", stat="identity"    ,
           colour="black", # Use black outlines,
           size=.3) +      # Thinner lines
  ggtitle("Expected Number of Wins by Scoring, Winner Take All")
plot(a)

```

The above plots show how Expected Total Profit and expected number of wins vary with scoring system and pool size. Percentile-.99 means you optimized the algorithm using .99-parameter and you will get $100 on a $1 entry if your bracket finishes >=99th percentile. From these plots, it is clear that AltScoring2 (1-1-1-1-1-1) is the best because it gives you a high expected total profit and also a high expected number of wins. Arithmetic (1-2-3-4-5-6), Exponential (1-2-4-8-16-32) and AltScoring (1-1-1-1-10-10) also do well. Upset scoring does not seem to make a huge difference--if anything it has a negative effect.


## Testing Pool Payouts

In addition to having different scoring systems, you can also have different payouts for your pool. I will look at two alternatives to winner-take-all.  <br /><br />

```{r , echo=F, eval=T , include=T ,fig.height = 3, fig.width =9, fig.align = "center"}
means<-ddply(backtest, .(Type, percentile, numBrackets),summarize,expectedNumLosses=sum((1-probWin)*(1-probSecond)), 
             expectedNumWins=sum(1-(1-probWin)*(1-probSecond)) 
             ,expectedProfit=sum(probWin*.75/(1-percentile)+probSecond*.25/(1-percentile)-1))
means$numBrackets<-as.factor(means$numBrackets)
means$percentile<-as.factor(means$percentile)
a<-ggplot(data=means, aes(fill=percentile, y=expectedProfit, x=Type)) +  
  geom_bar(position="dodge", stat="identity"    ,
           colour="black", # Use black outlines,
           size=.3) +      # Thinner lines
  ggtitle("Expected Total Profit By Scoring, 75% to Winner & 25% to Second")
plot(a)
a<-ggplot(data=means, aes(fill=percentile, y=expectedNumWins, x=Type)) +  
  geom_bar(position="dodge", stat="identity"    ,
           colour="black", # Use black outlines,
           size=.3) +      # Thinner lines
  ggtitle("Expected Wins By Scoring, 75% to Winner & 25% to Second")
plot(a)




means<-ddply(backtest, .(Type, percentile, numBrackets),summarize,expectedNumLosses=sum((1-probWin)*(1-probSecond)*(1-probThird)), 
             expectedNumWins=sum(1-(1-probWin)*(1-probSecond)*(1-probThird)), 
             expectedProfit=sum(probWin*.5/(1-percentile)+probSecond*.3/(1-percentile)+probThird*.2/(1-percentile)-1))
means$numBrackets<-as.factor(means$numBrackets)
means$percentile<-as.factor(means$percentile)
a<-ggplot(data=means, aes(fill=percentile, y=expectedProfit, x=Type)) +  
  geom_bar(position="dodge", stat="identity"    ,
           colour="black", # Use black outlines,
           size=.3) +      # Thinner lines
  ggtitle("Expected Total Profit By Scoring, 50% 1st, 30% 2nd, 20% 3rd")
plot(a)
a<-ggplot(data=means, aes(fill=percentile, y=expectedNumWins, x=Type)) +  
  geom_bar(position="dodge", stat="identity"    ,
           colour="black", # Use black outlines,
           size=.3) +      # Thinner lines
  ggtitle("Expected Wins By Scoring, 50% 1st, 30% 2nd, 20% 3rd")
plot(a)


```



The above results are not suprising. As the prize pool gets less top heavy, the expected number of wins goes up, but the expected total profit goes down. I define a "win" as any time your prize>entry. Obviously not all wins are created equal as a 3rd place "win" is less valuable, however, it this metric is still a decent measure of risk. <br />


##Conclusion

After analyzing the data, the first conclusion is that 1-1-1-1-1-1 scoring is the best. This it true because it will both give you higher expected profit and it will reduce your risk. 1-2-3-4-5-6 and 1-1-1-1-10-10 scoring also do pretty well, and the rest of them do slightly worse. Things like upset scoring do not seem to improve your chances, which is interesting because I was unsure about how it would do. In terms of pool payout/size, for this I am less clear on a conclusive answer. It is a matter of balancing Expected Total Profit with Risk. If it was me, I would enter 3 different brackets into 3 small, non winner take all pools. There do exist metrics like Sharpe ratio that try to balance gains with risk, however I am not sure how to apply that to this. Having said that, the main takeaway I would say is that certain scoring systems like 1-1-1-1-1 are clearly ideal. You can see the data for this post on [github](https://github.com/dlm1223/march-madness/tree/master/Backtest%20files) or can see use the [app](https://bracketmath.shinyapps.io/ncaa/) to try out some examples. <br /><br />




